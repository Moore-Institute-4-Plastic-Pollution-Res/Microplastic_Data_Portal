library(bs4Dash)
library(leaflet)
library(DT)
library(plotly)
library(readr)
library(dplyr)
library(tidyverse)
library(readxl)
library(tidygeocoder)
library(sf)  
library(mapview)
library(mapdata)
library(data.table)
library(shiny)
library(ggdist)
library(ggthemes)
library(ggplot2)
library(rlang)
library(PupillometryR)
library(gridExtra)
library(networkD3)
library(tidyr)
library(janitor)
library(RColorBrewer)

# Get the current working directory
wd <- getwd()

# Define the directory names
code <- c("code")
data_visualization <- c("data_visualization")
data_path <- c("data")

# Construct the full directory path
directory_path1 <- file.path(wd, code, data_visualization)

# Define the file name
file_name1 <- "merged_data.csv"  ### INSERT NAME OF INPUTTED CSV FILE HERE ###

# Construct the full file path
file_path1 <- file.path(wd, file_name1)

# merged_data <- read_csv(file_path1)
con <- mongo(
  url = "mongodb+srv://hannah:Singinglove2019@cluster0.hzb0jlh.mongodb.net/?retryWrites=true&w=majority",
  db = "test",
  collection = "One4All"
)
# Fetch data associated with the specific ObjectId
mongo_data <- con$find()
merged_data <- read.csv("/Users/nick_leong/Library/CloudStorage/GoogleDrive-nickleong@g.ucla.edu/My Drive/MIPPR/Microplastic_Data_Portal/code/data_visualization/merged_data.csv")

file_name2 <- "Samples_Geocoded.csv"

directory_path2 <- file.path(directory_path1, data_path)

file_path2 <- file.path(directory_path2, file_name2)


#cities_sf <- st_read("/Users/nick_leong/Downloads/City_Boundaries/City_Boundaries.shp")
file_name3 <- "CA_Places_TIGER2016.shp"
file_path3 <- file.path(directory_path2, "ca-places-boundaries")
file_path3 <- file.path(file_path3, file_name3)
cities <- st_read(file_path3)
cities <- clean_names(cities)
cities <- rename(cities, city = name)
file_name4 <- "CA_Counties_TIGER2016.shp"
file_path4 <- file.path(directory_path2, "CA_Counties")
file_path4 <- file.path(file_path4, file_name4)
counties <- st_read(file_path4)
counties <- clean_names(counties)
counties <- rename(counties, county = name)
# Create a new column in cities with the first 5 digits of geoid
cities <- mutate(cities, county_geoid = substr(geoid, 1, 5))

# Convert cities to sf object
cities_sf <- st_as_sf(cities, coords = c("longitude_column_name", "latitude_column_name"))

# Perform spatial join using st_join
cities_sf <- st_join(cities_sf, counties %>% select(geoid, county), by = c("county_geoid" = "geoid"))

# Clean the cities_sf_wgs84 data before Shiny app starts running
cities_sf_wgs84 <- st_transform(cities_sf, "+proj=longlat +datum=WGS84")
cities_sf_wgs84 <- clean_names(cities_sf_wgs84)

# Convert merged_data to an sf object and set CRS
merged_data_sf <- st_as_sf(merged_data, coords = c("longitude_new", "latitude_new"), crs = st_crs(cities_sf_wgs84))

merged_data_sf <- st_make_valid(merged_data_sf)
cities_sf_wgs84 <- st_make_valid(cities_sf_wgs84)
duplicated_rows <- duplicated(merged_data_sf)
merged_data_sf <- merged_data_sf[!duplicated_rows, ]
merged_data_sf <- st_simplify(merged_data_sf)
cities_sf_wgs84 <- st_simplify(cities_sf_wgs84)

# Spatial join to associate dam points with cities and counties
merged_data_sf <- st_join(merged_data_sf, cities_sf_wgs84, join = st_within)

#############################
ui <- bs4DashPage(
  bs4DashNavbar(
    title = "Microplastic Locations",
    tags$style(
      HTML(".navbar { background-color: #78909C; }")
    )
  ),
  bs4DashSidebar(
    tags$style(
      HTML(".sidebar { background-color: #78909C; }")
    ),
    sidebarMenu(
      menuItem("Interactive Map", tabName = "mapTab", icon = icon("map"))
    )
  ),
  bs4DashBody(
    tabItems(
      tabItem(
        tabName = "mapTab",
        fluidRow(
          box(
            title = "California Microplastics in Drinking Water",
            h3(
              tags$div(
                "Disclaimer: The data presented in this tab is entirely simulated for illustrative purposes and does not represent actual observations. This synthetic dataset is generated to demonstrate the functionality of the application and should not be interpreted as real-world information.",
                style = "font-size: 14px;"
              )
            ),
            width = 12
          ),
        ),
        fluidRow(
          column(
            width = 12,
            # Add yearSelect input above the first map
            selectInput("yearSelect", "Select Year", choices = 2024, selected = 2024)
          ),
          column(
            width = 12,
            leafletOutput("mapLocation")
          ),
          column(
            width = 6,
            selectInput("countySelect", "Select County", choices = NULL, multiple = TRUE)
          ),
          column(
            width = 6,
            selectInput("citySelect", "Select City", choices = NULL, multiple = TRUE)
          ),
          column(
            width = 12,
            box(
              title = "Plastic Data by Location",
              style = "overflow-x: auto;",
              DT::dataTableOutput("plastictableLocation"),
              width = 12
            )
          ),
          column(
            width = 12,
            box(
              title = "Shape Distribution",
              plotOutput("shapeBarPlot"),
              width = 12
            )
          ),
          column(
            width = 12,
            box(
              title = "Color Distribution",
              plotOutput("colorBarPlot"),
              width = 12
            )
          ),
          column(
            width = 12,
            box(
              title = "Polymer Distribution",
              plotOutput("polymerDistributionPlot"),
              width = 12
            )
          ),
          column(
            width = 12,
            box(
              title = "Width Distribution",
              plotOutput("widthBarPlot"),
              width = 12
            )
          ),
          column(
            width = 12,
            box(
              title = "Yearly Average Concentrations",
              plotOutput("stackedBarPlot"),
              width = 12
            )
          ),
          column(
            width = 12,
            box(
              title = "Treatment Library",
              width = 12,
              selectInput("treatmentSelect", "Select Treatment Level", choices = c("Primary", "Secondary", "Tertiary", "Disinfected", "Filtered"), multiple = TRUE),
              plotOutput("boxplotTreatment")
            )
          )
        )
      )
    )
  )
)



server <- function(input, output, session) {
  
  # Bar plot for "shape" within the app with reactivity
  output$shapeBarPlot <- renderPlot({
    filtered_data <- filtered_data()  # Get filtered data based on selectors
    
    ggplot(filtered_data, aes(x = shape)) +
      geom_bar(fill = "#4682B4") +
      labs(x = "Shape", y = "Count") +
      theme_minimal() +
      theme(text = element_text(size = 12, family = "Arial"))
  })
  
  # Bar plot for "color" within the app with reactivity
  output$colorBarPlot <- renderPlot({
    filtered_data <- filtered_data()  # Get filtered data based on selectors
    
    ggplot(filtered_data, aes(x = color)) +
      geom_bar(fill = "#708090") +
      labs(x = "Color", y = "Count") +
      theme_minimal() +
      theme(text = element_text(size = 12, family = "Arial"))
  })
  
  # Reactive expression for filtering based on county and city input
  polymer_distribution_data <- reactive({
    filtered_data <- filtered_data()  # Get filtered data based on selectors
    
    # Exclude rows with NA values in the polymer column GETTING RID OF NA VALUES, CHANGE WITH REAL DATA
    filtered_data <- filtered_data[!is.na(filtered_data$polymer), ]
    
    ggplot(filtered_data, aes(x = polymer)) +
      geom_bar(fill = "#4682B4") +
      labs(x = "Polymer", y = "Count") +
      theme_minimal() +
      theme(axis.text.x = element_text(angle = 45, hjust = 1)) +  # Rotate x-axis labels
      theme(text = element_text(size = 12, family = "Arial"))
  })
  
  
  # Bar plot for polymer distribution within the app with reactivity
  output$polymerDistributionPlot <- renderPlot({
    polymer_distribution_data()
  })
  
  
  # Bar plot for "width_mm" within the app with logarithmic scale and reactivity
  output$widthBarPlot <- renderPlot({
    filtered_data <- filtered_data()  # Get filtered data based on selectors
    
    ggplot(filtered_data, aes(x = width_mm)) +
      geom_bar(fill = "#708090", color = "#708090", linewidth = 0.5) +  # Adjust fill color, outline color, and size
      labs(x = "Width (mm)", y = "Count") +
      scale_x_log10() +  # Apply logarithmic scale to x-axis
      theme_minimal() +
      theme(axis.text.x = element_text(angle = 45, hjust = 1)) +  # Rotate x-axis labels
      theme(text = element_text(size = 12, family = "Arial"))
  })
  
  # Bar plot for yearly microplastic concentrations
  output$stackedBarPlot <- renderPlot({
    # Filtered data
    data <- filtered_data()
    
    # Initialize lists to store means and years
    means <- list()
    years <- list()
    
    # Iterate through years 2000 to 2024
    for (year in 2000:2024) {
      # Get column name for the year
      col_name <- paste0("m_ps_m3_", year)
      
      # Check if column exists in the data
      if (col_name %in% names(data)) {
        # Calculate mean concentration for the year
        means[[col_name]] <- mean(data[[col_name]], na.rm = TRUE)
        years[[col_name]] <- year
      }
    }
    
    # Combine means and years into single vectors
    means <- unlist(means)
    years <- unlist(years)
    
    # Plot the bar plot
    barplot(means, names.arg = years, xlab = "Year", ylab = "Mean Microplastic Concentration (P/m^3)", col = "#4682B4", ylim = c(0, max(means) * 1.2))
    
    # Add horizontal lines at specific y-axis values with ascending colors of concern
    abline(h = c(0.0003), lty = "dotted", lwd = 1, col = "#000000")
    abline(h = c(0.066), lty = "dotdash", lwd = 1, col = "#000000")
    abline(h = c(0.219), lty = "dashed", lwd = 1, col = "#000000")
    abline(h = c(0.859), lty = "solid", lwd = 1, col = "#000000")
    
    
    # Get the width of the plotting area
    plot_width <- par("usr")[2] - par("usr")[1]
    
    space_between_legends <- plot_width / 4
    
    # Calculate the x-coordinate for each legend
    legend_x1 <- par("usr")[1]
    legend_x2 <- legend_x1 + space_between_legends
    legend_x3 <- legend_x1 + 2 * space_between_legends
    legend_x4 <- legend_x1 + 3 * space_between_legends
    # Set the y-coordinate for the legends to be near the top of the plot
    legend_y <- par("usr")[4] - 0.05
    
    # Add legend
    legend(x = legend_x1, y = legend_y, legend = c("Threshold 1"), lty = "dotted", lwd = 0.75, col = "#000000", bty = "n", cex = 1)
    legend(x = legend_x2, y = legend_y, legend = c("Threshold 2"), lty = "dotdash", lwd = 0.75, col = "#000000", bty = "n", cex = 1)
    legend(x = legend_x3, y = legend_y, legend = c("Threshold 3"), lty = "dashed", lwd = 0.75, col = "#000000", bty = "n", cex = 1)
    legend(x = legend_x4, y = legend_y, legend = c("Threshold 4"), lty = "solid", lwd = 0.75, col = "#000000", bty = "n", cex = 1)
    
  })
  
  
  # Populate county choices for selectInput
  observe({
    county_choices <- unique(merged_data_sf$county)
    updateSelectInput(session, "countySelect", choices = county_choices)
  })
  
  # Populate city choices based on selected counties for selectInput
  observe({
    selected_counties <- input$countySelect
    city_choices <- unique(merged_data_sf$city[merged_data_sf$county %in% selected_counties])
    city_choices <- sort(city_choices)  # Sort the city choices alphabetically
    updateSelectInput(session, "citySelect", choices = city_choices)
  })
  
  # Reactive expression for filtering based on county and city input
  filtered_melted_data <- reactive({
    keyword <- input$damSearch
    selected_counties <- input$countySelect
    selected_cities <- input$citySelect
    
    # Filter by dam name
    filtered <- if (is.null(keyword) || keyword == "") {
      melted_data
    } else {
      melted_data[grep(keyword, melted_data$water_system_name, ignore.case = TRUE), ]
    }
    
    # Filter by selected counties
    if (!is.null(selected_counties) && length(selected_counties) > 0) {
      filtered <- filtered %>% filter(county %in% selected_counties)
    }
    
    # Filter by selected cities
    if (!is.null(selected_cities) && length(selected_cities) > 0) {
      filtered <- filtered %>% filter(city %in% selected_cities)
    }
    
    return(filtered)
  })
  
  # Reactive expression for filtering based on county and city input
  filtered_data <- reactive({
    keyword <- input$damSearch
    selected_counties <- input$countySelect
    selected_cities <- input$citySelect
    
    # Filter by water system name
    filtered <- if (is.null(keyword) || keyword == "") {
      merged_data_sf
    } else {
      merged_data_sf[grep(keyword, merged_data_sf$water_system_name, ignore.case = TRUE), ]
    }
    
    # Filter by selected counties
    if (!is.null(selected_counties) && length(selected_counties) > 0) {
      filtered <- filtered %>% filter(county %in% selected_counties)
    }
    
    # Filter by selected cities
    if (!is.null(selected_cities) && length(selected_cities) > 0) {
      filtered <- filtered %>% filter(city %in% selected_cities)
    }
    
    return(filtered)
  })
  
  # Location tab
  output$plastictableLocation <- DT::renderDataTable({
    data_to_display <- filtered_data() %>%
      select(county, city, water_system_name, m_ps_m3,shape,color,width_mm,polymer,latitude,longitude, treatment_level,m_ps_m3_2000, m_ps_m3_2001, m_ps_m3_2002, m_ps_m3_2003, m_ps_m3_2004, m_ps_m3_2005, m_ps_m3_2006, m_ps_m3_2007, m_ps_m3_2008, m_ps_m3_2009, m_ps_m3_2010, m_ps_m3_2011, m_ps_m3_2012, m_ps_m3_2013, m_ps_m3_2014, m_ps_m3_2015, m_ps_m3_2016, m_ps_m3_2017, m_ps_m3_2018, m_ps_m3_2019, m_ps_m3_2020, m_ps_m3_2021, m_ps_m3_2022, m_ps_m3_2023, m_ps_m3_2024 )%>%
      rename(
        County = county,
        City = city,
        "Water System Name" = water_system_name,
        "Concentration (Particles/m^3)" = m_ps_m3,
        "Morphology" = shape,
        "Color" = color,
        "Width (mm)" = width_mm,
        "Polymer" = polymer,
        "Latitude" = latitude,
        "Longitude" = longitude,
        "Treatment Level" = treatment_level,
        "Concentration (Particles/m^3) in 2000" = m_ps_m3_2000,
        "Concentration (Particles/m^3) in 2001" = m_ps_m3_2001,
        "Concentration (Particles/m^3) in 2002" = m_ps_m3_2002,
        "Concentration (Particles/m^3) in 2003" = m_ps_m3_2003,
        "Concentration (Particles/m^3) in 2004" = m_ps_m3_2004,
        "Concentration (Particles/m^3) in 2005" = m_ps_m3_2005,
        "Concentration (Particles/m^3) in 2006" = m_ps_m3_2006,
        "Concentration (Particles/m^3) in 2007" = m_ps_m3_2007,
        "Concentration (Particles/m^3) in 2008" = m_ps_m3_2008,
        "Concentration (Particles/m^3) in 2009" = m_ps_m3_2009,
        "Concentration (Particles/m^3) in 2010" = m_ps_m3_2010,
        "Concentration (Particles/m^3) in 2011" = m_ps_m3_2011,
        "Concentration (Particles/m^3) in 2012" = m_ps_m3_2012,
        "Concentration (Particles/m^3) in 2013" = m_ps_m3_2013,
        "Concentration (Particles/m^3) in 2014" = m_ps_m3_2014,
        "Concentration (Particles/m^3) in 2015" = m_ps_m3_2015,
        "Concentration (Particles/m^3) in 2016" = m_ps_m3_2016,
        "Concentration (Particles/m^3) in 2017" = m_ps_m3_2017,
        "Concentration (Particles/m^3) in 2018" = m_ps_m3_2018,
        "Concentration (Particles/m^3) in 2019" = m_ps_m3_2019,
        "Concentration (Particles/m^3) in 2020" = m_ps_m3_2020,
        "Concentration (Particles/m^3) in 2021" = m_ps_m3_2021,
        "Concentration (Particles/m^3) in 2022" = m_ps_m3_2022,
        "Concentration (Particles/m^3) in 2023" = m_ps_m3_2023,
        "Concentration (Particles/m^3) in 2024" = m_ps_m3_2024
      )
    
    datatable(data_to_display, style = "bootstrap", class = "cell-border stripe")
  })
  
  output$mapLocation1 <- renderLeaflet({
    leaflet() %>%
      setView(lng = -119.4179, lat = 36.7783, zoom = 6) %>%
      addTiles(urlTemplate = "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png") %>%
      addCircleMarkers(
        data = filtered_data(),
        clusterOptions = markerClusterOptions(),
        popup = paste0(
          "<div class='custom-popup'>",
          "<h4>Water System Details</h4>",
          "<p><strong>Water System Name:</strong> ", filtered_data()$water_system_name, "</p>",
          "<p><strong>Latitude:</strong> ", filtered_data()$latitude, "</p>",
          "<p><strong>Longitude:</strong> ", filtered_data()$longitude, "</p>",
          "<p><strong>Particles/m^3:</strong> ", filtered_data()$m_ps_m3, "</p>",
          "<p><strong>City:</strong> ", filtered_data()$city, "</p>",
          "<p><strong>County:</strong> ", filtered_data()$county, "</p>",
          "</div>"
        ),
        color = ~colorFactor("Set1", unique(filtered_data()$m_ps_m3))(m_ps_m3),
        fillOpacity = 0.8
      )
  })
  
  # Filtered data for box plots
  filtered_boxplot_data <- reactive({
    # Filter data based on selected treatment levels
    filtered_data <- merged_data_sf %>%
      filter(treatment_level %in% input$treatmentSelect)
    
    filtered_data
  })
  
  # Box plot for microplastic concentration based on treatment levels
  output$boxplotTreatment <- renderPlot({
    filtered_data <- filtered_boxplot_data()  # Get filtered data based on selected treatment levels
    
    # Plot box plots for microplastic concentration (m_ps_m3) based on treatment levels
    ggplot(filtered_data, aes(x = treatment_level, y = m_ps_m3)) +
      geom_boxplot(fill = "#708090") +
      labs(x = "Treatment Level", y = "Microplastic Concentration (m_ps_m3)") +
      theme_minimal() +
      theme(text = element_text(size = 12, family = "Arial"))
  })
}

shinyApp(ui, server)
